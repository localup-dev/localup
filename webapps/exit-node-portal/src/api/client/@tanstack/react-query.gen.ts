// This file is auto-generated by @hey-api/openapi-ts

import { type InfiniteData, infiniteQueryOptions, queryOptions, type UseMutationOptions } from '@tanstack/react-query';

import { client } from '../client.gen';
import { authConfig, cancelChallenge, completeChallenge, createAuthToken, deleteAuthToken, deleteCustomDomain, deleteTunnel, getAuthToken, getCurrentUser, getCustomDomain, getDomainById, getDomainChallenges, getLocalupMetrics, getRequest, getTunnel, healthCheck, initiateChallenge, listAuthTokens, listCustomDomains, listRequests, listTcpConnections, listTunnels, listUserTeams, login, logout, type Options, protocolDiscovery, register, replayRequest, requestAcmeCertificate, restartChallenge, serveAcmeChallenge, updateAuthToken, uploadCustomDomain } from '../sdk.gen';
import type { AuthConfigData, CancelChallengeData, CancelChallengeError, CompleteChallengeData, CompleteChallengeError, CompleteChallengeResponse, CreateAuthTokenData, CreateAuthTokenError, CreateAuthTokenResponse2, DeleteAuthTokenData, DeleteAuthTokenError, DeleteAuthTokenResponse, DeleteCustomDomainData, DeleteCustomDomainError, DeleteCustomDomainResponse, DeleteTunnelData, DeleteTunnelError, DeleteTunnelResponse, GetAuthTokenData, GetCurrentUserData, GetCustomDomainData, GetDomainByIdData, GetDomainChallengesData, GetLocalupMetricsData, GetRequestData, GetTunnelData, HealthCheckData, InitiateChallengeData, InitiateChallengeError, InitiateChallengeResponse2, ListAuthTokensData, ListCustomDomainsData, ListRequestsData, ListRequestsError, ListRequestsResponse, ListTcpConnectionsData, ListTcpConnectionsError, ListTcpConnectionsResponse, ListTunnelsData, ListUserTeamsData, LoginData, LoginError, LoginResponse2, LogoutData, LogoutError, ProtocolDiscoveryData, RegisterData, RegisterError, RegisterResponse2, ReplayRequestData, ReplayRequestError, ReplayRequestResponse, RequestAcmeCertificateData, RequestAcmeCertificateError, RequestAcmeCertificateResponse, RestartChallengeData, RestartChallengeError, RestartChallengeResponse, ServeAcmeChallengeData, UpdateAuthTokenData, UpdateAuthTokenError, UpdateAuthTokenResponse, UploadCustomDomainData, UploadCustomDomainError, UploadCustomDomainResponse2 } from '../types.gen';

export type QueryKey<TOptions extends Options> = [
    Pick<TOptions, 'baseUrl' | 'body' | 'headers' | 'path' | 'query'> & {
        _id: string;
        _infinite?: boolean;
        tags?: ReadonlyArray<string>;
    }
];

const createQueryKey = <TOptions extends Options>(id: string, options?: TOptions, infinite?: boolean, tags?: ReadonlyArray<string>): [
    QueryKey<TOptions>[0]
] => {
    const params: QueryKey<TOptions>[0] = { _id: id, baseUrl: options?.baseUrl || (options?.client ?? client).getConfig().baseUrl } as QueryKey<TOptions>[0];
    if (infinite) {
        params._infinite = infinite;
    }
    if (tags) {
        params.tags = tags;
    }
    if (options?.body) {
        params.body = options.body;
    }
    if (options?.headers) {
        params.headers = options.headers;
    }
    if (options?.path) {
        params.path = options.path;
    }
    if (options?.query) {
        params.query = options.query;
    }
    return [
        params
    ];
};

export const serveAcmeChallengeQueryKey = (options: Options<ServeAcmeChallengeData>) => createQueryKey('serveAcmeChallenge', options);

/**
 * Serve ACME HTTP-01 challenge response
 *
 * This endpoint serves the key authorization for ACME HTTP-01 challenges.
 * Let's Encrypt will request this URL to verify domain ownership.
 */
export const serveAcmeChallengeOptions = (options: Options<ServeAcmeChallengeData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await serveAcmeChallenge({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: serveAcmeChallengeQueryKey(options)
    });
};

export const protocolDiscoveryQueryKey = (options?: Options<ProtocolDiscoveryData>) => createQueryKey('protocolDiscovery', options);

/**
 * Get available transport protocols (well-known endpoint)
 *
 * This endpoint is used by clients to discover which transport protocols
 * are available on this relay (QUIC, WebSocket, HTTP/2).
 */
export const protocolDiscoveryOptions = (options?: Options<ProtocolDiscoveryData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await protocolDiscovery({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: protocolDiscoveryQueryKey(options)
    });
};

export const listAuthTokensQueryKey = (options?: Options<ListAuthTokensData>) => createQueryKey('listAuthTokens', options);

/**
 * List user's auth tokens
 */
export const listAuthTokensOptions = (options?: Options<ListAuthTokensData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await listAuthTokens({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: listAuthTokensQueryKey(options)
    });
};

/**
 * Create a new auth token (API key for tunnel authentication)
 */
export const createAuthTokenMutation = (options?: Partial<Options<CreateAuthTokenData>>): UseMutationOptions<CreateAuthTokenResponse2, CreateAuthTokenError, Options<CreateAuthTokenData>> => {
    const mutationOptions: UseMutationOptions<CreateAuthTokenResponse2, CreateAuthTokenError, Options<CreateAuthTokenData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await createAuthToken({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Delete (revoke) an auth token
 */
export const deleteAuthTokenMutation = (options?: Partial<Options<DeleteAuthTokenData>>): UseMutationOptions<DeleteAuthTokenResponse, DeleteAuthTokenError, Options<DeleteAuthTokenData>> => {
    const mutationOptions: UseMutationOptions<DeleteAuthTokenResponse, DeleteAuthTokenError, Options<DeleteAuthTokenData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await deleteAuthToken({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getAuthTokenQueryKey = (options: Options<GetAuthTokenData>) => createQueryKey('getAuthToken', options);

/**
 * Get specific auth token details
 */
export const getAuthTokenOptions = (options: Options<GetAuthTokenData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getAuthToken({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getAuthTokenQueryKey(options)
    });
};

/**
 * Update auth token (name, description, or active status)
 */
export const updateAuthTokenMutation = (options?: Partial<Options<UpdateAuthTokenData>>): UseMutationOptions<UpdateAuthTokenResponse, UpdateAuthTokenError, Options<UpdateAuthTokenData>> => {
    const mutationOptions: UseMutationOptions<UpdateAuthTokenResponse, UpdateAuthTokenError, Options<UpdateAuthTokenData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await updateAuthToken({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const authConfigQueryKey = (options?: Options<AuthConfigData>) => createQueryKey('authConfig', options);

/**
 * Get authentication configuration
 */
export const authConfigOptions = (options?: Options<AuthConfigData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await authConfig({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: authConfigQueryKey(options)
    });
};

/**
 * Login with email and password
 */
export const loginMutation = (options?: Partial<Options<LoginData>>): UseMutationOptions<LoginResponse2, LoginError, Options<LoginData>> => {
    const mutationOptions: UseMutationOptions<LoginResponse2, LoginError, Options<LoginData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await login({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Logout (clear session cookie)
 */
export const logoutMutation = (options?: Partial<Options<LogoutData>>): UseMutationOptions<unknown, LogoutError, Options<LogoutData>> => {
    const mutationOptions: UseMutationOptions<unknown, LogoutError, Options<LogoutData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await logout({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getCurrentUserQueryKey = (options?: Options<GetCurrentUserData>) => createQueryKey('getCurrentUser', options);

/**
 * Get current authenticated user
 */
export const getCurrentUserOptions = (options?: Options<GetCurrentUserData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getCurrentUser({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getCurrentUserQueryKey(options)
    });
};

/**
 * Register a new user
 */
export const registerMutation = (options?: Partial<Options<RegisterData>>): UseMutationOptions<RegisterResponse2, RegisterError, Options<RegisterData>> => {
    const mutationOptions: UseMutationOptions<RegisterResponse2, RegisterError, Options<RegisterData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await register({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const listCustomDomainsQueryKey = (options?: Options<ListCustomDomainsData>) => createQueryKey('listCustomDomains', options);

/**
 * List all custom domains
 */
export const listCustomDomainsOptions = (options?: Options<ListCustomDomainsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await listCustomDomains({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: listCustomDomainsQueryKey(options)
    });
};

/**
 * Upload a custom domain certificate
 */
export const uploadCustomDomainMutation = (options?: Partial<Options<UploadCustomDomainData>>): UseMutationOptions<UploadCustomDomainResponse2, UploadCustomDomainError, Options<UploadCustomDomainData>> => {
    const mutationOptions: UseMutationOptions<UploadCustomDomainResponse2, UploadCustomDomainError, Options<UploadCustomDomainData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await uploadCustomDomain({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getDomainByIdQueryKey = (options: Options<GetDomainByIdData>) => createQueryKey('getDomainById', options);

/**
 * Get a custom domain by ID
 */
export const getDomainByIdOptions = (options: Options<GetDomainByIdData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getDomainById({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getDomainByIdQueryKey(options)
    });
};

/**
 * Complete/verify ACME challenge
 */
export const completeChallengeMutation = (options?: Partial<Options<CompleteChallengeData>>): UseMutationOptions<CompleteChallengeResponse, CompleteChallengeError, Options<CompleteChallengeData>> => {
    const mutationOptions: UseMutationOptions<CompleteChallengeResponse, CompleteChallengeError, Options<CompleteChallengeData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await completeChallenge({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Initiate ACME challenge for a domain
 */
export const initiateChallengeMutation = (options?: Partial<Options<InitiateChallengeData>>): UseMutationOptions<InitiateChallengeResponse2, InitiateChallengeError, Options<InitiateChallengeData>> => {
    const mutationOptions: UseMutationOptions<InitiateChallengeResponse2, InitiateChallengeError, Options<InitiateChallengeData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await initiateChallenge({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Delete a custom domain
 */
export const deleteCustomDomainMutation = (options?: Partial<Options<DeleteCustomDomainData>>): UseMutationOptions<DeleteCustomDomainResponse, DeleteCustomDomainError, Options<DeleteCustomDomainData>> => {
    const mutationOptions: UseMutationOptions<DeleteCustomDomainResponse, DeleteCustomDomainError, Options<DeleteCustomDomainData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await deleteCustomDomain({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getCustomDomainQueryKey = (options: Options<GetCustomDomainData>) => createQueryKey('getCustomDomain', options);

/**
 * Get a specific custom domain
 */
export const getCustomDomainOptions = (options: Options<GetCustomDomainData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getCustomDomain({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getCustomDomainQueryKey(options)
    });
};

/**
 * Request Let's Encrypt certificate for a domain
 *
 * This initiates the ACME HTTP-01 challenge flow and provisions a certificate.
 * The domain must resolve to this server for the challenge to succeed.
 */
export const requestAcmeCertificateMutation = (options?: Partial<Options<RequestAcmeCertificateData>>): UseMutationOptions<RequestAcmeCertificateResponse, RequestAcmeCertificateError, Options<RequestAcmeCertificateData>> => {
    const mutationOptions: UseMutationOptions<RequestAcmeCertificateResponse, RequestAcmeCertificateError, Options<RequestAcmeCertificateData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await requestAcmeCertificate({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Cancel a pending ACME challenge
 */
export const cancelChallengeMutation = (options?: Partial<Options<CancelChallengeData>>): UseMutationOptions<unknown, CancelChallengeError, Options<CancelChallengeData>> => {
    const mutationOptions: UseMutationOptions<unknown, CancelChallengeError, Options<CancelChallengeData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await cancelChallenge({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Restart ACME challenge for a domain (cancel existing and start new)
 */
export const restartChallengeMutation = (options?: Partial<Options<RestartChallengeData>>): UseMutationOptions<RestartChallengeResponse, RestartChallengeError, Options<RestartChallengeData>> => {
    const mutationOptions: UseMutationOptions<RestartChallengeResponse, RestartChallengeError, Options<RestartChallengeData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await restartChallenge({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getDomainChallengesQueryKey = (options: Options<GetDomainChallengesData>) => createQueryKey('getDomainChallenges', options);

/**
 * Get pending challenges for a domain
 *
 * Returns any pending ACME challenges for the specified domain.
 */
export const getDomainChallengesOptions = (options: Options<GetDomainChallengesData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getDomainChallenges({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getDomainChallengesQueryKey(options)
    });
};

export const healthCheckQueryKey = (options?: Options<HealthCheckData>) => createQueryKey('healthCheck', options);

/**
 * Health check endpoint
 */
export const healthCheckOptions = (options?: Options<HealthCheckData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await healthCheck({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: healthCheckQueryKey(options)
    });
};

export const listRequestsQueryKey = (options?: Options<ListRequestsData>) => createQueryKey('listRequests', options);

/**
 * List captured requests (traffic inspector)
 */
export const listRequestsOptions = (options?: Options<ListRequestsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await listRequests({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: listRequestsQueryKey(options)
    });
};

const createInfiniteParams = <K extends Pick<QueryKey<Options>[0], 'body' | 'headers' | 'path' | 'query'>>(queryKey: QueryKey<Options>, page: K) => {
    const params = {
        ...queryKey[0]
    };
    if (page.body) {
        params.body = {
            ...queryKey[0].body as any,
            ...page.body as any
        };
    }
    if (page.headers) {
        params.headers = {
            ...queryKey[0].headers,
            ...page.headers
        };
    }
    if (page.path) {
        params.path = {
            ...queryKey[0].path as any,
            ...page.path as any
        };
    }
    if (page.query) {
        params.query = {
            ...queryKey[0].query as any,
            ...page.query as any
        };
    }
    return params as unknown as typeof page;
};

export const listRequestsInfiniteQueryKey = (options?: Options<ListRequestsData>): QueryKey<Options<ListRequestsData>> => createQueryKey('listRequests', options, true);

/**
 * List captured requests (traffic inspector)
 */
export const listRequestsInfiniteOptions = (options?: Options<ListRequestsData>) => {
    return infiniteQueryOptions<ListRequestsResponse, ListRequestsError, InfiniteData<ListRequestsResponse>, QueryKey<Options<ListRequestsData>>, number | Pick<QueryKey<Options<ListRequestsData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
    // @ts-ignore
    {
        queryFn: async ({ pageParam, queryKey, signal }) => {
            // @ts-ignore
            const page: Pick<QueryKey<Options<ListRequestsData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
                query: {
                    offset: pageParam
                }
            };
            const params = createInfiniteParams(queryKey, page);
            const { data } = await listRequests({
                ...options,
                ...params,
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: listRequestsInfiniteQueryKey(options)
    });
};

export const getRequestQueryKey = (options: Options<GetRequestData>) => createQueryKey('getRequest', options);

/**
 * Get a specific captured request
 */
export const getRequestOptions = (options: Options<GetRequestData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getRequest({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getRequestQueryKey(options)
    });
};

/**
 * Replay a captured request
 */
export const replayRequestMutation = (options?: Partial<Options<ReplayRequestData>>): UseMutationOptions<ReplayRequestResponse, ReplayRequestError, Options<ReplayRequestData>> => {
    const mutationOptions: UseMutationOptions<ReplayRequestResponse, ReplayRequestError, Options<ReplayRequestData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await replayRequest({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const listTcpConnectionsQueryKey = (options?: Options<ListTcpConnectionsData>) => createQueryKey('listTcpConnections', options);

/**
 * List captured TCP connections (traffic inspector)
 */
export const listTcpConnectionsOptions = (options?: Options<ListTcpConnectionsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await listTcpConnections({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: listTcpConnectionsQueryKey(options)
    });
};

export const listTcpConnectionsInfiniteQueryKey = (options?: Options<ListTcpConnectionsData>): QueryKey<Options<ListTcpConnectionsData>> => createQueryKey('listTcpConnections', options, true);

/**
 * List captured TCP connections (traffic inspector)
 */
export const listTcpConnectionsInfiniteOptions = (options?: Options<ListTcpConnectionsData>) => {
    return infiniteQueryOptions<ListTcpConnectionsResponse, ListTcpConnectionsError, InfiniteData<ListTcpConnectionsResponse>, QueryKey<Options<ListTcpConnectionsData>>, number | Pick<QueryKey<Options<ListTcpConnectionsData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
    // @ts-ignore
    {
        queryFn: async ({ pageParam, queryKey, signal }) => {
            // @ts-ignore
            const page: Pick<QueryKey<Options<ListTcpConnectionsData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
                query: {
                    offset: pageParam
                }
            };
            const params = createInfiniteParams(queryKey, page);
            const { data } = await listTcpConnections({
                ...options,
                ...params,
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: listTcpConnectionsInfiniteQueryKey(options)
    });
};

export const listUserTeamsQueryKey = (options?: Options<ListUserTeamsData>) => createQueryKey('listUserTeams', options);

/**
 * Get user's teams
 */
export const listUserTeamsOptions = (options?: Options<ListUserTeamsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await listUserTeams({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: listUserTeamsQueryKey(options)
    });
};

export const listTunnelsQueryKey = (options?: Options<ListTunnelsData>) => createQueryKey('listTunnels', options);

/**
 * List all tunnels (active and optionally inactive)
 */
export const listTunnelsOptions = (options?: Options<ListTunnelsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await listTunnels({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: listTunnelsQueryKey(options)
    });
};

/**
 * Delete a tunnel
 */
export const deleteTunnelMutation = (options?: Partial<Options<DeleteTunnelData>>): UseMutationOptions<DeleteTunnelResponse, DeleteTunnelError, Options<DeleteTunnelData>> => {
    const mutationOptions: UseMutationOptions<DeleteTunnelResponse, DeleteTunnelError, Options<DeleteTunnelData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await deleteTunnel({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getTunnelQueryKey = (options: Options<GetTunnelData>) => createQueryKey('getTunnel', options);

/**
 * Get a specific tunnel by ID
 */
export const getTunnelOptions = (options: Options<GetTunnelData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getTunnel({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getTunnelQueryKey(options)
    });
};

export const getLocalupMetricsQueryKey = (options: Options<GetLocalupMetricsData>) => createQueryKey('getLocalupMetrics', options);

/**
 * Get tunnel metrics
 */
export const getLocalupMetricsOptions = (options: Options<GetLocalupMetricsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getLocalupMetrics({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getLocalupMetricsQueryKey(options)
    });
};
