// This file is auto-generated by @hey-api/openapi-ts

export type ClientOptions = {
    baseUrl: 'http://localhost:13080' | (string & {});
};

/**
 * Authentication configuration
 */
export type AuthConfig = {
    /**
     * Whether public user registration is allowed
     */
    signup_enabled: boolean;
};

/**
 * Auth token information (without the actual token value)
 */
export type AuthToken = {
    /**
     * When the token was created
     */
    created_at: string;
    /**
     * Token description
     */
    description?: string | null;
    /**
     * When the token expires (null = never)
     */
    expires_at?: string | null;
    /**
     * Token ID
     */
    id: string;
    /**
     * Whether the token is active
     */
    is_active: boolean;
    /**
     * When the token was last used
     */
    last_used_at?: string | null;
    /**
     * Token name
     */
    name: string;
    /**
     * Team ID if this is a team token
     */
    team_id?: string | null;
    /**
     * User ID who owns this token
     */
    user_id: string;
};

/**
 * List of auth tokens
 */
export type AuthTokenList = {
    /**
     * Auth tokens
     */
    tokens: Array<AuthToken>;
    /**
     * Total count
     */
    total: number;
};

/**
 * HTTP request captured in traffic inspector
 */
export type CapturedRequest = {
    /**
     * Request body (base64 encoded if binary)
     */
    body?: string | null;
    /**
     * Request duration in milliseconds
     */
    duration_ms?: number | null;
    /**
     * Request headers
     */
    headers: Array<[
        string,
        string
    ]>;
    /**
     * Unique request ID
     */
    id: string;
    /**
     * Tunnel ID this request belongs to
     */
    localup_id: string;
    /**
     * HTTP method
     */
    method: string;
    /**
     * Request path
     */
    path: string;
    /**
     * Response body (base64 encoded if binary)
     */
    response_body?: string | null;
    /**
     * Response headers
     */
    response_headers?: Array<[
        string,
        string
    ]> | null;
    /**
     * Request size in bytes
     */
    size_bytes: number;
    /**
     * Response status code
     */
    status?: number | null;
    /**
     * Request timestamp
     */
    timestamp: string;
};

/**
 * List of captured requests with pagination metadata
 */
export type CapturedRequestList = {
    /**
     * Page size limit
     */
    limit: number;
    /**
     * Current page offset
     */
    offset: number;
    /**
     * Captured requests
     */
    requests: Array<CapturedRequest>;
    /**
     * Total count (without pagination)
     */
    total: number;
};

/**
 * Query parameters for filtering captured requests
 */
export type CapturedRequestQuery = {
    /**
     * Pagination limit (default: 100, max: 1000)
     */
    limit?: number | null;
    /**
     * Filter by tunnel ID
     */
    localup_id?: string | null;
    /**
     * Filter by HTTP method
     */
    method?: string | null;
    /**
     * Pagination offset (default: 0)
     */
    offset?: number | null;
    /**
     * Filter by path (supports partial match)
     */
    path?: string | null;
    /**
     * Filter by status code
     */
    status?: number | null;
    /**
     * Filter by maximum status code (for range queries)
     */
    status_max?: number | null;
    /**
     * Filter by minimum status code (for range queries)
     */
    status_min?: number | null;
};

/**
 * TCP connection information
 */
export type CapturedTcpConnection = {
    /**
     * Bytes received from client
     */
    bytes_received: number;
    /**
     * Bytes sent to client
     */
    bytes_sent: number;
    /**
     * Client address
     */
    client_addr: string;
    /**
     * Connection timestamp
     */
    connected_at: string;
    /**
     * Disconnect reason
     */
    disconnect_reason?: string | null;
    /**
     * Disconnection timestamp
     */
    disconnected_at?: string | null;
    /**
     * Connection duration in milliseconds
     */
    duration_ms?: number | null;
    /**
     * Connection ID
     */
    id: string;
    /**
     * Tunnel ID
     */
    localup_id: string;
    /**
     * Target port
     */
    target_port: number;
};

/**
 * List of TCP connections with pagination
 */
export type CapturedTcpConnectionList = {
    /**
     * TCP connections
     */
    connections: Array<CapturedTcpConnection>;
    /**
     * Page size
     */
    limit: number;
    /**
     * Current offset
     */
    offset: number;
    /**
     * Total count (without pagination)
     */
    total: number;
};

/**
 * Query parameters for filtering TCP connections
 */
export type CapturedTcpConnectionQuery = {
    /**
     * Filter by client address (partial match)
     */
    client_addr?: string | null;
    /**
     * Pagination limit (default: 100, max: 1000)
     */
    limit?: number | null;
    /**
     * Filter by tunnel ID
     */
    localup_id?: string | null;
    /**
     * Pagination offset
     */
    offset?: number | null;
    /**
     * Filter by target port
     */
    target_port?: number | null;
};

/**
 * Challenge information for domain validation
 */
export type ChallengeInfo = {
    /**
     * Domain being validated
     */
    domain: string;
    /**
     * Where to place the file
     * Format: http://{domain}/.well-known/acme-challenge/{token}
     */
    file_path: string;
    /**
     * Instructions for user
     */
    instructions: Array<string>;
    /**
     * Key authorization to serve
     */
    key_authorization: string;
    /**
     * Random token from ACME server
     */
    token: string;
    type: 'http01';
} | {
    /**
     * Domain being validated
     */
    domain: string;
    /**
     * Instructions for user
     */
    instructions: Array<string>;
    /**
     * DNS record name (_acme-challenge.{domain})
     */
    record_name: string;
    /**
     * DNS TXT record value
     */
    record_value: string;
    type: 'dns01';
};

/**
 * Request to complete/verify a challenge
 */
export type CompleteChallengeRequest = {
    /**
     * Challenge ID from initiate response
     */
    challenge_id: string;
    /**
     * Domain name
     */
    domain: string;
};

/**
 * Request to create an auth token
 */
export type CreateAuthTokenRequest = {
    /**
     * Description of what this token is used for (optional)
     */
    description?: string | null;
    /**
     * Token expiration in days (null = never expires)
     */
    expires_in_days?: number | null;
    /**
     * User-defined name for this token
     */
    name: string;
    /**
     * Team ID if this is a team token (optional)
     */
    team_id?: string | null;
};

/**
 * Response after creating an auth token
 */
export type CreateAuthTokenResponse = {
    /**
     * When the token was created
     */
    created_at: string;
    /**
     * When the token expires (null = never)
     */
    expires_at?: string | null;
    /**
     * Token ID
     */
    id: string;
    /**
     * Token name
     */
    name: string;
    /**
     * The actual JWT token (SHOWN ONLY ONCE!)
     */
    token: string;
};

/**
 * Request to create a new tunnel
 */
export type CreateTunnelRequest = {
    /**
     * List of endpoints to create
     */
    endpoints: Array<TunnelProtocol>;
    /**
     * Desired region (optional, auto-selected if not specified)
     */
    region?: string | null;
};

/**
 * Response when creating a tunnel
 */
export type CreateTunnelResponse = {
    /**
     * Authentication token for connecting
     */
    token: string;
    /**
     * Created tunnel information
     */
    tunnel: Tunnel;
};

/**
 * Custom domain information
 */
export type CustomDomain = {
    /**
     * Whether to automatically renew the certificate
     */
    auto_renew: boolean;
    /**
     * Domain name
     */
    domain: string;
    /**
     * Error message if provisioning failed
     */
    error_message?: string | null;
    /**
     * When the certificate expires
     */
    expires_at?: string | null;
    /**
     * When the certificate was provisioned
     */
    provisioned_at: string;
    /**
     * Certificate status
     */
    status: CustomDomainStatus;
};

/**
 * List of custom domains
 */
export type CustomDomainList = {
    /**
     * Custom domains
     */
    domains: Array<CustomDomain>;
    /**
     * Total count
     */
    total: number;
};

/**
 * Custom domain status
 */
export type CustomDomainStatus = 'pending' | 'active' | 'expired' | 'failed';

/**
 * Error response
 */
export type ErrorResponse = {
    /**
     * Error code
     */
    code?: string | null;
    /**
     * Error message
     */
    error: string;
};

/**
 * Health check response
 */
export type HealthResponse = {
    /**
     * Active tunnels count
     */
    active_tunnels: number;
    /**
     * Service status
     */
    status: string;
    /**
     * Service version
     */
    version: string;
};

/**
 * Request to initiate ACME challenge for a domain
 */
export type InitiateChallengeRequest = {
    /**
     * Challenge type (http-01 or dns-01)
     */
    challenge_type?: string;
    /**
     * Domain name to validate
     */
    domain: string;
};

/**
 * Response after initiating a challenge
 */
export type InitiateChallengeResponse = {
    /**
     * Challenge details
     */
    challenge: ChallengeInfo;
    /**
     * Challenge ID for completing the validation
     */
    challenge_id: string;
    /**
     * Domain name
     */
    domain: string;
    /**
     * Expiration time for this challenge
     */
    expires_at: string;
};

/**
 * User login request
 */
export type LoginRequest = {
    /**
     * User email address
     */
    email: string;
    /**
     * User password
     */
    password: string;
};

/**
 * User login response
 */
export type LoginResponse = {
    /**
     * Token expiration timestamp
     */
    expires_at: string;
    /**
     * Session token
     */
    token: string;
    /**
     * Logged in user
     */
    user: User;
};

/**
 * User registration request
 */
export type RegisterRequest = {
    /**
     * User email address (must be unique)
     */
    email: string;
    /**
     * User full name (optional)
     */
    full_name?: string | null;
    /**
     * User password (minimum 8 characters)
     */
    password: string;
};

/**
 * User registration response
 */
export type RegisterResponse = {
    /**
     * Authentication token for tunnel connections (only shown once)
     */
    auth_token: string;
    /**
     * Token expiration timestamp
     */
    expires_at: string;
    /**
     * Session token for immediate login
     */
    token: string;
    /**
     * Newly created user
     */
    user: User;
};

/**
 * Team information
 */
export type Team = {
    /**
     * When the team was created
     */
    created_at: string;
    /**
     * Team UUID
     */
    id: string;
    /**
     * Team name
     */
    name: string;
    /**
     * User ID of the team owner
     */
    owner_id: string;
    /**
     * Team slug (URL-friendly)
     */
    slug: string;
    /**
     * When the team was last updated
     */
    updated_at: string;
};

/**
 * List of teams
 */
export type TeamList = {
    /**
     * Teams
     */
    teams: Array<Team>;
    /**
     * Total count
     */
    total: number;
};

/**
 * Team member information
 */
export type TeamMember = {
    /**
     * When the user joined the team
     */
    joined_at: string;
    /**
     * Role in the team
     */
    role: TeamRole;
    /**
     * Team ID
     */
    team_id: string;
    /**
     * User information
     */
    user: User;
};

/**
 * Team role
 */
export type TeamRole = 'owner' | 'admin' | 'member';

/**
 * Tunnel information
 */
export type Tunnel = {
    /**
     * Connection timestamp
     */
    connected_at: string;
    /**
     * Tunnel endpoints
     */
    endpoints: Array<TunnelEndpoint>;
    /**
     * Unique tunnel identifier
     */
    id: string;
    /**
     * Local address being forwarded
     */
    local_addr?: string | null;
    /**
     * Tunnel region/location
     */
    region: string;
    /**
     * Tunnel status
     */
    status: TunnelStatus;
};

/**
 * Tunnel endpoint information
 */
export type TunnelEndpoint = {
    /**
     * Allocated port (for TCP tunnels)
     */
    port?: number | null;
    /**
     * Protocol type
     */
    protocol: TunnelProtocol;
    /**
     * Public URL accessible from internet
     */
    public_url: string;
};

/**
 * List of tunnels
 */
export type TunnelList = {
    /**
     * Total count
     */
    total: number;
    /**
     * Tunnels
     */
    tunnels: Array<Tunnel>;
};

/**
 * Tunnel metrics
 */
export type TunnelMetrics = {
    /**
     * Average latency in milliseconds
     */
    avg_latency_ms: number;
    /**
     * Error rate (0.0 to 1.0)
     */
    error_rate: number;
    /**
     * Tunnel ID
     */
    localup_id: string;
    /**
     * Requests per minute
     */
    requests_per_minute: number;
    /**
     * Total bandwidth in bytes
     */
    total_bandwidth_bytes: number;
    /**
     * Total requests
     */
    total_requests: number;
};

/**
 * Tunnel protocol type
 */
export type TunnelProtocol = {
    /**
     * Subdomain for the tunnel
     */
    subdomain: string;
    type: 'http';
} | {
    /**
     * Subdomain for the tunnel
     */
    subdomain: string;
    type: 'https';
} | {
    /**
     * Local port to forward
     */
    port: number;
    type: 'tcp';
} | {
    /**
     * Domain for SNI routing
     */
    domain: string;
    type: 'tls';
};

/**
 * Tunnel status
 */
export type TunnelStatus = 'connected' | 'disconnected' | 'connecting' | 'error';

/**
 * Request to update an auth token
 */
export type UpdateAuthTokenRequest = {
    /**
     * Updated description (optional)
     */
    description?: string | null;
    /**
     * Whether the token is active (optional)
     */
    is_active?: boolean | null;
    /**
     * Updated token name (optional)
     */
    name?: string | null;
};

/**
 * Request to upload a custom domain certificate
 */
export type UploadCustomDomainRequest = {
    /**
     * Whether to automatically renew the certificate
     */
    auto_renew?: boolean;
    /**
     * Certificate in PEM format (base64 encoded)
     */
    cert_pem: string;
    /**
     * Domain name (e.g., "api.example.com")
     */
    domain: string;
    /**
     * Private key in PEM format (base64 encoded)
     */
    key_pem: string;
};

/**
 * Response after uploading a custom domain
 */
export type UploadCustomDomainResponse = {
    /**
     * Domain name
     */
    domain: string;
    /**
     * Success message
     */
    message: string;
    /**
     * Current status
     */
    status: CustomDomainStatus;
};

/**
 * User information
 */
export type User = {
    /**
     * When the user was created
     */
    created_at: string;
    /**
     * User email
     */
    email: string;
    /**
     * User full name
     */
    full_name?: string | null;
    /**
     * User UUID
     */
    id: string;
    /**
     * Whether the account is active
     */
    is_active: boolean;
    /**
     * User role
     */
    role: UserRole;
    /**
     * When the user was last updated
     */
    updated_at: string;
};

/**
 * List of users
 */
export type UserList = {
    /**
     * Total count
     */
    total: number;
    /**
     * Users
     */
    users: Array<User>;
};

/**
 * User role
 */
export type UserRole = 'admin' | 'user';

export type ListAuthTokensData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/api/auth-tokens';
};

export type ListAuthTokensErrors = {
    /**
     * Unauthorized
     */
    401: ErrorResponse;
    /**
     * Internal server error
     */
    500: ErrorResponse;
};

export type ListAuthTokensError = ListAuthTokensErrors[keyof ListAuthTokensErrors];

export type ListAuthTokensResponses = {
    /**
     * List of auth tokens
     */
    200: AuthTokenList;
};

export type ListAuthTokensResponse = ListAuthTokensResponses[keyof ListAuthTokensResponses];

export type CreateAuthTokenData = {
    body: CreateAuthTokenRequest;
    path?: never;
    query?: never;
    url: '/api/auth-tokens';
};

export type CreateAuthTokenErrors = {
    /**
     * Unauthorized
     */
    401: ErrorResponse;
    /**
     * Internal server error
     */
    500: ErrorResponse;
};

export type CreateAuthTokenError = CreateAuthTokenErrors[keyof CreateAuthTokenErrors];

export type CreateAuthTokenResponses = {
    /**
     * Auth token created successfully
     */
    201: CreateAuthTokenResponse;
};

export type CreateAuthTokenResponse2 = CreateAuthTokenResponses[keyof CreateAuthTokenResponses];

export type DeleteAuthTokenData = {
    body?: never;
    path: {
        /**
         * Auth token ID
         */
        id: string;
    };
    query?: never;
    url: '/api/auth-tokens/{id}';
};

export type DeleteAuthTokenErrors = {
    /**
     * Unauthorized
     */
    401: ErrorResponse;
    /**
     * Token not found
     */
    404: ErrorResponse;
    /**
     * Internal server error
     */
    500: ErrorResponse;
};

export type DeleteAuthTokenError = DeleteAuthTokenErrors[keyof DeleteAuthTokenErrors];

export type DeleteAuthTokenResponses = {
    /**
     * Auth token deleted successfully
     */
    204: void;
};

export type DeleteAuthTokenResponse = DeleteAuthTokenResponses[keyof DeleteAuthTokenResponses];

export type GetAuthTokenData = {
    body?: never;
    path: {
        /**
         * Auth token ID
         */
        id: string;
    };
    query?: never;
    url: '/api/auth-tokens/{id}';
};

export type GetAuthTokenErrors = {
    /**
     * Unauthorized
     */
    401: ErrorResponse;
    /**
     * Token not found
     */
    404: ErrorResponse;
    /**
     * Internal server error
     */
    500: ErrorResponse;
};

export type GetAuthTokenError = GetAuthTokenErrors[keyof GetAuthTokenErrors];

export type GetAuthTokenResponses = {
    /**
     * Auth token details
     */
    200: AuthToken;
};

export type GetAuthTokenResponse = GetAuthTokenResponses[keyof GetAuthTokenResponses];

export type UpdateAuthTokenData = {
    body: UpdateAuthTokenRequest;
    path: {
        /**
         * Auth token ID
         */
        id: string;
    };
    query?: never;
    url: '/api/auth-tokens/{id}';
};

export type UpdateAuthTokenErrors = {
    /**
     * Unauthorized
     */
    401: ErrorResponse;
    /**
     * Token not found
     */
    404: ErrorResponse;
    /**
     * Internal server error
     */
    500: ErrorResponse;
};

export type UpdateAuthTokenError = UpdateAuthTokenErrors[keyof UpdateAuthTokenErrors];

export type UpdateAuthTokenResponses = {
    /**
     * Auth token updated
     */
    200: AuthToken;
};

export type UpdateAuthTokenResponse = UpdateAuthTokenResponses[keyof UpdateAuthTokenResponses];

export type AuthConfigData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/api/auth/config';
};

export type AuthConfigResponses = {
    /**
     * Authentication configuration
     */
    200: AuthConfig;
};

export type AuthConfigResponse = AuthConfigResponses[keyof AuthConfigResponses];

export type LoginData = {
    body: LoginRequest;
    path?: never;
    query?: never;
    url: '/api/auth/login';
};

export type LoginErrors = {
    /**
     * Invalid credentials
     */
    401: ErrorResponse;
    /**
     * Internal server error
     */
    500: ErrorResponse;
};

export type LoginError = LoginErrors[keyof LoginErrors];

export type LoginResponses = {
    /**
     * Login successful
     */
    200: LoginResponse;
};

export type LoginResponse2 = LoginResponses[keyof LoginResponses];

export type LogoutData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/api/auth/logout';
};

export type LogoutErrors = {
    /**
     * Internal server error
     */
    500: ErrorResponse;
};

export type LogoutError = LogoutErrors[keyof LogoutErrors];

export type LogoutResponses = {
    /**
     * Logout successful
     */
    200: unknown;
};

export type GetCurrentUserData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/api/auth/me';
};

export type GetCurrentUserErrors = {
    /**
     * Not authenticated
     */
    401: ErrorResponse;
};

export type GetCurrentUserError = GetCurrentUserErrors[keyof GetCurrentUserErrors];

export type GetCurrentUserResponses = {
    /**
     * Current user info
     */
    200: {
        [key: string]: unknown;
    };
};

export type GetCurrentUserResponse = GetCurrentUserResponses[keyof GetCurrentUserResponses];

export type RegisterData = {
    body: RegisterRequest;
    path?: never;
    query?: never;
    url: '/api/auth/register';
};

export type RegisterErrors = {
    /**
     * Invalid request or email already exists
     */
    400: ErrorResponse;
    /**
     * Internal server error
     */
    500: ErrorResponse;
};

export type RegisterError = RegisterErrors[keyof RegisterErrors];

export type RegisterResponses = {
    /**
     * User registered successfully
     */
    201: RegisterResponse;
};

export type RegisterResponse2 = RegisterResponses[keyof RegisterResponses];

export type ListCustomDomainsData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/api/domains';
};

export type ListCustomDomainsErrors = {
    /**
     * Internal server error
     */
    500: ErrorResponse;
};

export type ListCustomDomainsError = ListCustomDomainsErrors[keyof ListCustomDomainsErrors];

export type ListCustomDomainsResponses = {
    /**
     * List of custom domains
     */
    200: CustomDomainList;
};

export type ListCustomDomainsResponse = ListCustomDomainsResponses[keyof ListCustomDomainsResponses];

export type UploadCustomDomainData = {
    body: UploadCustomDomainRequest;
    path?: never;
    query?: never;
    url: '/api/domains';
};

export type UploadCustomDomainErrors = {
    /**
     * Invalid request
     */
    400: ErrorResponse;
    /**
     * Internal server error
     */
    500: ErrorResponse;
};

export type UploadCustomDomainError = UploadCustomDomainErrors[keyof UploadCustomDomainErrors];

export type UploadCustomDomainResponses = {
    /**
     * Certificate uploaded successfully
     */
    201: UploadCustomDomainResponse;
};

export type UploadCustomDomainResponse2 = UploadCustomDomainResponses[keyof UploadCustomDomainResponses];

export type CompleteChallengeData = {
    body: CompleteChallengeRequest;
    path?: never;
    query?: never;
    url: '/api/domains/challenge/complete';
};

export type CompleteChallengeErrors = {
    /**
     * ACME not yet implemented
     */
    501: ErrorResponse;
};

export type CompleteChallengeError = CompleteChallengeErrors[keyof CompleteChallengeErrors];

export type CompleteChallengeResponses = {
    /**
     * Challenge completed, certificate issued
     */
    200: UploadCustomDomainResponse;
};

export type CompleteChallengeResponse = CompleteChallengeResponses[keyof CompleteChallengeResponses];

export type InitiateChallengeData = {
    body: InitiateChallengeRequest;
    path?: never;
    query?: never;
    url: '/api/domains/challenge/initiate';
};

export type InitiateChallengeErrors = {
    /**
     * ACME not yet implemented
     */
    501: ErrorResponse;
};

export type InitiateChallengeError = InitiateChallengeErrors[keyof InitiateChallengeErrors];

export type InitiateChallengeResponses = {
    /**
     * Challenge initiated
     */
    200: InitiateChallengeResponse;
};

export type InitiateChallengeResponse2 = InitiateChallengeResponses[keyof InitiateChallengeResponses];

export type DeleteCustomDomainData = {
    body?: never;
    path: {
        /**
         * Domain name
         */
        domain: string;
    };
    query?: never;
    url: '/api/domains/{domain}';
};

export type DeleteCustomDomainErrors = {
    /**
     * Domain not found
     */
    404: ErrorResponse;
    /**
     * Internal server error
     */
    500: ErrorResponse;
};

export type DeleteCustomDomainError = DeleteCustomDomainErrors[keyof DeleteCustomDomainErrors];

export type DeleteCustomDomainResponses = {
    /**
     * Domain deleted successfully
     */
    204: void;
};

export type DeleteCustomDomainResponse = DeleteCustomDomainResponses[keyof DeleteCustomDomainResponses];

export type GetCustomDomainData = {
    body?: never;
    path: {
        /**
         * Domain name
         */
        domain: string;
    };
    query?: never;
    url: '/api/domains/{domain}';
};

export type GetCustomDomainErrors = {
    /**
     * Domain not found
     */
    404: ErrorResponse;
    /**
     * Internal server error
     */
    500: ErrorResponse;
};

export type GetCustomDomainError = GetCustomDomainErrors[keyof GetCustomDomainErrors];

export type GetCustomDomainResponses = {
    /**
     * Custom domain details
     */
    200: CustomDomain;
};

export type GetCustomDomainResponse = GetCustomDomainResponses[keyof GetCustomDomainResponses];

export type HealthCheckData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/api/health';
};

export type HealthCheckResponses = {
    /**
     * Service is healthy
     */
    200: HealthResponse;
};

export type HealthCheckResponse = HealthCheckResponses[keyof HealthCheckResponses];

export type ListRequestsData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Filter by tunnel ID
         */
        localup_id?: string;
        /**
         * Filter by HTTP method (GET, POST, etc.)
         */
        method?: string;
        /**
         * Filter by path (supports partial match)
         */
        path?: string;
        /**
         * Filter by exact status code
         */
        status?: number;
        /**
         * Filter by minimum status code
         */
        status_min?: number;
        /**
         * Filter by maximum status code
         */
        status_max?: number;
        /**
         * Pagination offset (default: 0)
         */
        offset?: number;
        /**
         * Pagination limit (default: 100, max: 1000)
         */
        limit?: number;
    };
    url: '/api/requests';
};

export type ListRequestsErrors = {
    /**
     * Internal server error
     */
    500: ErrorResponse;
};

export type ListRequestsError = ListRequestsErrors[keyof ListRequestsErrors];

export type ListRequestsResponses = {
    /**
     * List of captured requests
     */
    200: CapturedRequestList;
};

export type ListRequestsResponse = ListRequestsResponses[keyof ListRequestsResponses];

export type GetRequestData = {
    body?: never;
    path: {
        /**
         * Request ID
         */
        id: string;
    };
    query?: never;
    url: '/api/requests/{id}';
};

export type GetRequestErrors = {
    /**
     * Request not found
     */
    404: ErrorResponse;
    /**
     * Internal server error
     */
    500: ErrorResponse;
};

export type GetRequestError = GetRequestErrors[keyof GetRequestErrors];

export type GetRequestResponses = {
    /**
     * Captured request details
     */
    200: CapturedRequest;
};

export type GetRequestResponse = GetRequestResponses[keyof GetRequestResponses];

export type ReplayRequestData = {
    body?: never;
    path: {
        /**
         * Request ID
         */
        id: string;
    };
    query?: never;
    url: '/api/requests/{id}/replay';
};

export type ReplayRequestErrors = {
    /**
     * Request not found
     */
    404: ErrorResponse;
    /**
     * Internal server error
     */
    500: ErrorResponse;
};

export type ReplayRequestError = ReplayRequestErrors[keyof ReplayRequestErrors];

export type ReplayRequestResponses = {
    /**
     * Request replayed successfully
     */
    200: CapturedRequest;
};

export type ReplayRequestResponse = ReplayRequestResponses[keyof ReplayRequestResponses];

export type ListTcpConnectionsData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Filter by tunnel ID
         */
        localup_id?: string;
        /**
         * Filter by client address (partial match)
         */
        client_addr?: string;
        /**
         * Filter by target port
         */
        target_port?: number;
        /**
         * Pagination offset (default: 0)
         */
        offset?: number;
        /**
         * Pagination limit (default: 100, max: 1000)
         */
        limit?: number;
    };
    url: '/api/tcp-connections';
};

export type ListTcpConnectionsErrors = {
    /**
     * Internal server error
     */
    500: ErrorResponse;
};

export type ListTcpConnectionsError = ListTcpConnectionsErrors[keyof ListTcpConnectionsErrors];

export type ListTcpConnectionsResponses = {
    /**
     * List of TCP connections
     */
    200: CapturedTcpConnectionList;
};

export type ListTcpConnectionsResponse = ListTcpConnectionsResponses[keyof ListTcpConnectionsResponses];

export type ListUserTeamsData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/api/teams';
};

export type ListUserTeamsErrors = {
    /**
     * Not authenticated
     */
    401: ErrorResponse;
};

export type ListUserTeamsError = ListUserTeamsErrors[keyof ListUserTeamsErrors];

export type ListUserTeamsResponses = {
    /**
     * List of user's teams
     */
    200: {
        [key: string]: unknown;
    };
};

export type ListUserTeamsResponse = ListUserTeamsResponses[keyof ListUserTeamsResponses];

export type ListTunnelsData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Include inactive/disconnected tunnels from history (default: false)
         */
        include_inactive?: boolean;
    };
    url: '/api/tunnels';
};

export type ListTunnelsErrors = {
    /**
     * Internal server error
     */
    500: ErrorResponse;
};

export type ListTunnelsError = ListTunnelsErrors[keyof ListTunnelsErrors];

export type ListTunnelsResponses = {
    /**
     * List of tunnels
     */
    200: TunnelList;
};

export type ListTunnelsResponse = ListTunnelsResponses[keyof ListTunnelsResponses];

export type DeleteTunnelData = {
    body?: never;
    path: {
        /**
         * Tunnel ID
         */
        id: string;
    };
    query?: never;
    url: '/api/tunnels/{id}';
};

export type DeleteTunnelErrors = {
    /**
     * Tunnel not found
     */
    404: ErrorResponse;
    /**
     * Internal server error
     */
    500: ErrorResponse;
};

export type DeleteTunnelError = DeleteTunnelErrors[keyof DeleteTunnelErrors];

export type DeleteTunnelResponses = {
    /**
     * Tunnel deleted successfully
     */
    204: void;
};

export type DeleteTunnelResponse = DeleteTunnelResponses[keyof DeleteTunnelResponses];

export type GetTunnelData = {
    body?: never;
    path: {
        /**
         * Tunnel ID
         */
        id: string;
    };
    query?: never;
    url: '/api/tunnels/{id}';
};

export type GetTunnelErrors = {
    /**
     * Tunnel not found
     */
    404: ErrorResponse;
    /**
     * Internal server error
     */
    500: ErrorResponse;
};

export type GetTunnelError = GetTunnelErrors[keyof GetTunnelErrors];

export type GetTunnelResponses = {
    /**
     * Tunnel information
     */
    200: Tunnel;
};

export type GetTunnelResponse = GetTunnelResponses[keyof GetTunnelResponses];

export type GetLocalupMetricsData = {
    body?: never;
    path: {
        /**
         * Tunnel ID
         */
        id: string;
    };
    query?: never;
    url: '/api/tunnels/{id}/metrics';
};

export type GetLocalupMetricsErrors = {
    /**
     * Tunnel not found
     */
    404: ErrorResponse;
    /**
     * Internal server error
     */
    500: ErrorResponse;
};

export type GetLocalupMetricsError = GetLocalupMetricsErrors[keyof GetLocalupMetricsErrors];

export type GetLocalupMetricsResponses = {
    /**
     * Tunnel metrics
     */
    200: TunnelMetrics;
};

export type GetLocalupMetricsResponse = GetLocalupMetricsResponses[keyof GetLocalupMetricsResponses];
